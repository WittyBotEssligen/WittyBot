import streamlit as st
from WittyBot_V05_optimiert import WittyBotCore, AppConfig
from datetime import datetime
import logging
from pathlib import Path
import sqlite3
import time
import streamlit.components.v1 as components
import base64

# Erstellt eine SQLite-Datenbank f√ºr allgemeines Feedback, falls sie noch nicht existiert
def init_feedback_db():
    db_path = Path("feedback.db")
    if not db_path.exists():
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS feedback (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            stars INTEGER,
            comment TEXT,
            question TEXT,
            answer TEXT
        )
        """)
        conn.commit()
        conn.close()
init_feedback_db()

# üß± Initialisierung der Datenbank f√ºr Einzel-Feedbacks
def init_message_feedback_db():
    # Definiert den Pfad zur Datenbankdatei
    db_path = Path("message_feedback.db")

    # Falls die Datei noch nicht existiert, wird sie erstellt
    if not db_path.exists():
        # Verbindung zur neuen SQLite-Datenbank aufbauen
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Tabelle 'message_feedback' erstellen, wenn sie noch nicht existiert
        # Sie speichert:
        # - ID (automatisch hochgez√§hlt)
        # - Zeitstempel des Feedbacks
        # - Die urspr√ºngliche Frage
        # - Die gegebene Antwort
        # - Die Bewertung (z.‚ÄØB. +1 oder -1)
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS message_feedback (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            question TEXT,
            answer TEXT,
            rating INTEGER
        )
        """)
        # √Ñnderungen speichern und Verbindung schlie√üen
        conn.commit()
        conn.close()
# F√ºhrt die Initialisierung direkt beim Start des Programms aus
init_message_feedback_db()

# üìã Aktiviert das Logging-System f√ºr die Anwendung.
# Damit werden Laufzeitinformationen (wie Infos, Warnungen, Fehler) in der Konsole ausgegeben.
# Das ist sehr n√ºtzlich f√ºr die sp√§tere Fehlersuche oder zur √úberwachung der Bot-Aktivit√§t.
logging.basicConfig(
    level=logging.INFO,  # Mindestlevel: Nur Meldungen ab "INFO" werden angezeigt (INFO, WARNING, ERROR, CRITICAL)
    format="%(asctime)s - %(levelname)s - %(message)s",  # Format der Ausgabe: Zeitstempel ‚Äì Level ‚Äì Nachricht
    handlers=[logging.StreamHandler()]  # Ausgabeziel: Konsole (Standardausgabe)
)

# üß≠ Seitenkonfiguration festlegen
st.set_page_config(
    page_title="WittyBot ‚Äì Dein Studienassistent",  # Titel im Browser-Tab
    page_icon="img/logo.png",                       # Icon im Browser-Tab (z.‚ÄØB. neben dem Titel)
    layout="wide"                                   # Breites Layout (mehr Platz f√ºr Inhalte)
)
    
# üíú Stil (Individuelle Gestaltung des Interfaces √ºber CS–´)
# Das CSS wird in einem Markdown-Block direkt in den Streamlit-HTML-Code eingef√ºgt.
st.markdown("""
    <style>
    /* üßë‚Äçüéì Nachricht des Users: Hintergrund & Stil */
    .stChatMessage.user div:nth-child(2) {
        background-color: #E6E6FA !important;   /* Hell-lila Hintergrund */
        border-radius: 15px;                    /* Abgerundete Ecken */
        padding: 10px 15px;                     /* Innenabstand */
    }

    /* üé® Seitenleiste: Farbgebung */
    [data-testid="stSidebar"] {
        background-color: #F5F3FF !important;   /* Hell-violett */
    }

    /* üïí Zeitstempel-Stil */
    .timestamp {
        font-size: 11px;        /* Kleine Schriftgr√∂√üe */
        color: #888;            /* Graue Farbe */
        margin-top: 4px;        /* Abstand nach oben */
    }

    /* ‚úçÔ∏è Eingabefeld: normaler Zustand */
    textarea {
        background-color: #F5F3FF !important;  /* Hellvioletter Hintergrund */
        transition: background-color 0.3s ease;  /* Weicher Farb√ºbergang */
        border-radius: 10px !important;       /* Runde Ecken */
        color: black !important;              /* Schwarzer Text */
    }

    /* ‚úçÔ∏è Eingabefeld: wenn aktiv (fokussiert) */
    textarea:focus {
        background-color: #E0D4FA !important;  /* Etwas dunkler beim Klicken */
        outline: none !important;              /* Kein Standard-Fokusrahmen */
    }

    /* ‚ùå Stil f√ºr "Antwort abbrechen"-Knopf */
    .abort-button button {
        font-size: 12px !important;
        padding: 3px 8px !important;
        border-radius: 10px !important;
        background-color: #ffecec !important;  /* Rosa Hintergrund */
        color: #800000 !important;             /* Dunkelrot f√ºr Text */
        border: 1px solid #e0a0a0 !important;   /* Roter Rahmen */
        margin-top: 5px;
        margin-bottom: 10px;
    }

    /* üß© Sekund√§rbuttons (z.‚ÄØB. Feedback-Sterne) ‚Äì kleinere Schrift */
    button[kind="secondary"] span {
        font-size: 12px !important;
    }

    /* üß± Hauptcontainer (Inhalt in der Mitte & verbreitert) */
    .block-container {
        max-width: 860px;             /* Max. Breite */
        padding-left: 2rem;           /* Abstand links */
        padding-right: 2rem;          /* Abstand rechts */
        margin: auto;                 /* Zentriert */
    }

    /* ‚å®Ô∏è Eingabefeld im Chat an Hauptbreite anpassen */
    div[data-testid="stChatInput"] {
        max-width: 740px !important;  /* Gleiche Breite wie Inhalte */
        margin-left: auto !important;
        margin-right: auto !important;
    }

    </style>
""", unsafe_allow_html=True)


# üìö Seitenleiste (Sidebar): enth√§lt Logo, Titel, Feedback-Formular und ggf. Admin-Optionen
with st.sidebar:
    st.image("img/logo.png", width=100)  # Logo anzeigen
    st.title("üìö WittyBot")  # Titel des Bots in der Seitenleiste
    st.markdown("Dein intelligenter Studienassistent ü§ñ")  # Kurze Beschreibung

    # ‚≠ê Abschnitt f√ºr allgemeines Feedback zum gesamten Chat
    st.markdown("### üåü Feedback zum Gespr√§ch")

    # Falls noch kein Feedback gegeben wurde, wird es erlaubt
    if "feedback_given" not in st.session_state:
        st.session_state.feedback_given = False

    # Nur anzeigen, wenn noch kein Feedback abgegeben wurde
    if not st.session_state.feedback_given:
        # ‚≠ê Sternebewertung: Skala von 1 (schlecht) bis 5 (sehr hilfreich)
        stars = st.slider("Wie hilfreich war das gesamte Gespr√§ch?", 1, 5, 3)
        st.caption("1 = schlecht, 5 = sehr hilfreich")

        comment = ""
        # Wenn Bewertung ‚â§ 2: Kommentarfeld anzeigen
        if stars <= 2:
            comment = st.text_area("Was war unklar oder schlecht?")

        # üì© Button zum Absenden des Feedbacks
        if st.button("üì© Feedback absenden"):

            messages = st.session_state.get("messages", [])  # Alle Chat-Nachrichten
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # Zeitpunkt speichern
            entries = []  # Liste aller Eintr√§ge f√ºr die Datenbank

            # ‚ûï Alle Frage-Antwort-Paare zusammenstellen
            i = 0
            while i < len(messages) - 1:
                q = messages[i]
                a = messages[i + 1]

                if q["role"] == "user":
                    # Antwort-Text pr√ºfen
                    answer_text = ""
                    if a["role"] == "assistant":
                        answer_text = a["content"]
                    else:
                        answer_text = "‚ö†Ô∏è Keine Antwort erhalten."  # Wenn keine Antwort vorhanden

                    # Feedback-Eintrag speichern
                    entries.append((timestamp, stars, comment, q["content"], answer_text))
                    i += 2  # Weiter zum n√§chsten Paar
                else:
                    i += 1

            # üóÉÔ∏è Speichern des Feedbacks in die Datenbank
            if entries:
                try:
                    conn = sqlite3.connect("feedback.db")  # Verbindung zur DB
                    cursor = conn.cursor()
                    cursor.executemany(
                        "INSERT INTO feedback (timestamp, stars, comment, question, answer) VALUES (?, ?, ?, ?, ?)",
                        entries  # Mehrere Eintr√§ge gleichzeitig einf√ºgen
                    )
                    conn.commit()
                    conn.close()
                    st.session_state.feedback_given = True  # Kein erneutes Feedback m√∂glich
                    st.success("‚úÖ Danke f√ºr dein Feedback zum Gespr√§ch!")  # Erfolgsmeldung
                except Exception as e:
                    st.error(f"‚ùå Fehler beim Speichern: {e}")  # Fehler beim Speichern
            else:
                st.warning("‚ö†Ô∏è Keine Frage-Antwort-Paare gefunden.")  # Kein Inhalt zum Speichern
    else:
        # Falls bereits Feedback gegeben wurde
        st.success("‚úÖ Feedback wurde bereits abgeschickt.")

# üóëÔ∏è Chat l√∂schen ‚Äì damit kann der Benutzer den gesamten bisherigen Verlauf zur√ºcksetzen
    if st.button("üóëÔ∏è Chatverlauf l√∂schen"):
        st.session_state.messages = []             # Alle bisherigen Chatnachrichten l√∂schen
        st.session_state.aborted = False           # Zur√ºcksetzen, falls vorher eine Antwort abgebrochen wurde
        st.session_state.is_thinking = False       # Bot ist nicht mehr ‚Äûam Denken‚Äú
        st.session_state.feedback_mode = False     # Feedback-Modus wird deaktiviert
        st.session_state.feedback_incorrect = False  # R√ºckmeldung √ºber falsche Antwort zur√ºcksetzen
        st.rerun()  # üîÑ Seite neu laden, um den Zustand sofort sichtbar zu machen
     
    # üîê Admin-Bereich ‚Äì nur f√ºr berechtigte Personen mit Passwort sichtbar
    st.markdown("---")  # Trennlinie im Seitenlayout
    st.subheader("üîê Admin-Zugang")  # Abschnittstitel

    # Pr√ºfen, ob der Admin-Status bereits in der Sitzung gespeichert ist
    if "is_admin" not in st.session_state:
        st.session_state.is_admin = False

    # ‚úÖ Wenn Admin bereits eingeloggt ist:
    if st.session_state.is_admin:
        st.success("‚úÖ Admin-Zugang aktiv")  # Gr√ºne Erfolgsmeldung
        st.markdown("‚Äì Neue Dateien ‚Üí in den Ordner `/data/` legen")  # Hinweis f√ºr Dokumentenpflege

        # üîÑ M√∂glichkeit zum Neuladen der Dokumentenbasis (Vektor-Datenbank)
        if st.button("üîÑ Dokumente neu laden"):
            config = AppConfig()                    # Konfiguration neu laden
            bot = WittyBotCore(config)              # Bot mit aktueller Konfiguration starten
            bot.reload_vector_db()                  # Dokumente erneut verarbeiten
            st.success("Vektor-Datenbank wurde aktualisiert!")  # Erfolgsmeldung

        # üîí Ausloggen-Funktion
        if st.button("üîí Ausloggen"):
            st.session_state.is_admin = False       # Admin-Modus deaktivieren
            st.success("Du wurdest ausgeloggt.")    # Best√§tigung

    # ‚ùå Wenn nicht eingeloggt:
    else:
        # Passwort-Eingabe f√ºr Admin-Zugang
        admin_pw = st.text_input("Admin-Passwort eingeben:", type="password")

        # Klick auf "Einloggen"-Button
        if st.button("üîì Einloggen"):
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # Aktuelle Zeit f√ºr Log
            try:
                ip = st.query_params.get("ip", ["unknown"])[0]  # IP-Adresse (optional)
            except:
                ip = "unknown"

            # üîë Pr√ºfung des Passworts (hier hartkodiert!)
            if admin_pw == "ichbindumm":
                st.session_state.is_admin = True     # Admin-Rechte aktivieren
                st.success("‚úÖ Admin-Zugang aktiviert!")  # Erfolgsmeldung

                # Erfolgreiches Login in Datei protokollieren
                with open("admin_logins.txt", "a", encoding="utf-8") as f:
                    f.write(f"[{now}] Erfolgreich ‚Äì IP: {ip}\n")
            else:
                st.error("‚ùå Falsches Passwort. Bitte wende dich an das Projektteam.")  # Fehleranzeige

                # Fehlgeschlagenes Login protokollieren
                with open("admin_logins.txt", "a", encoding="utf-8") as f:
                    f.write(f"[{now}] Fehlgeschlagen ‚Äì IP: {ip} ‚Äì Passwort: {admin_pw}\n")

import hashlib

def generate_message_key(question, answer, timestamp):
    """Generiert eindeutigen Hash-Schl√ºssel f√ºr eine Frage-Antwort-Kombination zu einem bestimmten Zeitpunkt.
    Dies dient dazu, Feedback eindeutig zu identifizieren und doppelte Bewertungen zu verhindern.
    Die Kombination aus Frage, Antwort und Zeit wird in einen MD5-Hash umgewandelt.
    """
    return hashlib.md5(f"{question}|{answer}|{timestamp}".encode("utf-8")).hexdigest()

def save_message_feedback(question, answer, rating):
    # Speichert das Feedback zu einer einzelnen Frage-Antwort-Kombination in die SQLite-Datenbank

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # Aktueller Zeitstempel im Format "2024-05-18 14:32:00"
    try:
        conn = sqlite3.connect("message_feedback.db")
        cursor = conn.cursor()  

        # SQL-Befehl zum Einf√ºgen der Daten (Frage, Antwort, Bewertung, Zeit)
        cursor.execute("""
            INSERT INTO message_feedback (timestamp, question, answer, rating)
            VALUES (?, ?, ?, ?)
        """, (timestamp, question, answer, rating))

        conn.commit()  # √Ñnderungen speichern
        conn.close()   # Verbindung schlie√üen
    except Exception as e:
        # Falls ein Fehler auftritt, wird dieser ins Log geschrieben
        logging.error(f"Fehler beim Speichern des Einzel-Feedbacks: {e}")

# üöÄ Initialisierung von Sitzungsvariablen (Session State)
# Diese werden nur einmal beim Start gesetzt ‚Äì wenn sie noch nicht existieren

# Bot-Instanz nur einmal initialisieren (Konfiguration + Kernlogik laden)
if "bot" not in st.session_state:
    config = AppConfig()                    # l√§dt alle Systempfade und Modelleinstellungen
    st.session_state.bot = WittyBotCore(config)  # erstellt die zentrale Bot-Instanz

# Nachrichtenverlauf (Chat) initialisieren
if "messages" not in st.session_state:
    st.session_state.messages = []          # speichert alle bisherigen Nachrichten

# Zustand: Ob der Bot aktuell ‚Äûnachdenkt‚Äú (Antwort generiert)
if "is_thinking" not in st.session_state:
    st.session_state.is_thinking = False

# Zustand: Wurde der ‚ÄûAntwort abbrechen‚Äú-Button gedr√ºckt?
if "abort_triggered" not in st.session_state:
    st.session_state.abort_triggered = False

# Zustand: Ist aktuell Feedback erlaubt f√ºr die letzte Antwort?
if "feedback_mode" not in st.session_state:
    st.session_state.feedback_mode = False

# Zustand: Admin hat eine falsche Antwort erkannt und will korrigieren
if "feedback_incorrect" not in st.session_state:
    st.session_state.feedback_incorrect = False

# Zustand: ‚ÄûDanke f√ºr Feedback‚Äú-Hinweis anzeigen?
if "feedback_thanks" not in st.session_state:
    st.session_state.feedback_thanks = False

# ‚¨áÔ∏è Weitere Feedback-bezogene Zust√§nde

# Erneut gesetzt (doppelt, aber zur Sicherheit)
if "feedback_thanks" not in st.session_state:
    st.session_state.feedback_thanks = False

# Zeitpunkt der letzten Feedbackaktion (f√ºr sp√§tere Zeitpr√ºfungen)
if "feedback_time" not in st.session_state:
    st.session_state.feedback_time = None

# Pro Nachricht: Wurde schon Feedback gegeben? (Verhindert mehrfaches Bewerten)
if "feedback_given_per_message" not in st.session_state:
    st.session_state.feedback_given_per_message = {}


# üñêÔ∏è Begr√º√üungsnachricht des Assistenten
# Wird nur angezeigt, wenn der Chat leer ist (also beim ersten Start)
if not st.session_state.messages:
    st.session_state.messages.append({
        "role": "assistant",  # Rolle: Bot
        "content": "Hallo, ich bin **WittyBot** ü§ñ ‚Äì dein Studienassistent! Wie kann ich dir helfen?",
        "time": datetime.now().strftime("%d.%m.%Y, %H:%M")  # Aktueller Zeitstempel
    })

# üì• Eingabefeld f√ºr die Nutzerfrage
user_input = None

# Eingabefeld nur anzeigen, wenn Bot nicht gerade antwortet
if not st.session_state.is_thinking:
    # Nutzer kann hier eine Frage stellen
    user_input = st.chat_input("Was m√∂chtest du wissen?")
else:
    # Eingabefeld ist deaktiviert, solange Antwort generiert wird
    st.chat_input("WittyBot antwortet gerade... Bitte warte ‚è≥", disabled=True)

# üì§ Wenn der Benutzer etwas eingegeben hat (eine neue Frage)
if user_input:
    st.session_state.latest_question = user_input  # Speichere die Frage
    st.session_state.current_time = datetime.now().strftime("%d.%m.%Y, %H:%M")  # Aktuelle Uhrzeit speichern
    st.session_state.is_thinking = True           # Setze Status: Bot antwortet
    st.session_state.aborted = False              # Antwort wurde noch nicht abgebrochen
    st.rerun()                                     # Streamlit wird neu gestartet ‚Üí Anzeige wird aktualisiert

# üí¨ Wenn der Bot gerade antwortet
if st.session_state.is_thinking and "latest_question" in st.session_state:
    user_input = st.session_state.latest_question
    current_time = st.session_state.current_time

    # üí¨ Zeige die Frage des Nutzers im Chat
    with st.chat_message("user", avatar="img/user.png"):
        st.markdown(f"<div style='text-align: right'>{user_input}<div class='timestamp'>{current_time}</div></div>", unsafe_allow_html=True)

    # ü§ñ Wenn keine Abbruch-Anfrage vorliegt
    if not st.session_state.abort_triggered:
        with st.chat_message("assistant", avatar="img/logo.png"):

            # üß† Text: Der Bot denkt nach...
            st.markdown("WittyBot denkt nach... üí≠")

            # ‚ùå Abbrechen-Button anzeigen
            st.markdown('<div class="abort-button">', unsafe_allow_html=True)
            if st.button("‚úñÔ∏è Antwort abbrechen"):
                st.session_state.abort_triggered = True
                st.rerun()
            st.markdown('</div>', unsafe_allow_html=True)

        # üåÄ Animation (Lottie) Llama ‚Äì zentriert unter dem Abbrechen-Button
        import json
        with open("img/loading.json", "r", encoding="utf-8") as f:
            lottie_json = json.dumps(json.load(f))

        components.html(f"""
            <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
            <div style="display: flex; justify-content: center; margin-top: 4px;">
                <lottie-player
                    autoplay
                    loop
                    mode="normal"
                    style="width: 200px; height: 200px;"
                    src='data:application/json;base64,{base64.b64encode(lottie_json.encode()).decode()}' >
                </lottie-player>
            </div>
        """, height=260)

        # üß† Der Bot generiert jetzt die Antwort
        response = st.session_state.bot.handle_query(user_input)

        # Wenn Antwort nicht abgebrochen wurde ‚Üí Antwort anzeigen
        if not st.session_state.aborted:
            st.markdown(f"{response}<div class='timestamp'>{current_time}</div>", unsafe_allow_html=True)

        # ‚úÖ Speichere Frage + Antwort im Verlauf
        if not st.session_state.aborted:
            st.session_state.messages.append({
                "role": "user",
                "content": user_input,
                "time": current_time
            })
            st.session_state.messages.append({
                "role": "assistant",
                "content": response,
                "time": current_time
            })
            st.session_state.latest_answer = response
            st.session_state.feedback_mode = True  # Feedback-Modus aktivieren (f√ºr Admin)
    
        # Zur√ºcksetzen aller tempor√§ren Zust√§nde
        st.session_state.is_thinking = False
        del st.session_state.latest_question
        del st.session_state.current_time
        st.rerun()
    
    # ‚ùå Wenn die Antwort abgebrochen wurde
    else:
        st.session_state.messages.append({
            "role": "user",
            "content": user_input,
            "time": current_time
        })
        st.session_state.messages.append({
            "role": "assistant",
            "content": "Antwort wurde abgebrochen.",
            "time": current_time
        })
        st.session_state.is_thinking = False
        st.session_state.aborted = True
        st.session_state.abort_triggered = False
    
        # Aufr√§umen der Variablen
        if "latest_question" in st.session_state:
            del st.session_state.latest_question
        if "current_time" in st.session_state:
            del st.session_state.current_time
    
        st.rerun()

# üìã Funktion: Kopier-Button f√ºr Nachrichten
# F√ºgt einen kleinen Button ein, mit dem man Text in die Zwischenablage kopieren kann
def copy_button(text):
    components.html(f"""
        <button onclick="navigator.clipboard.writeText(`{text}`)"
                style="background: none; border: none; padding: 0; margin: 0; cursor: pointer; font-size: 16px;">
            üìã
        </button>
    """, height=35)

# Chat anzeigen
for msg in st.session_state.messages:
    timestamp = f"<div class='timestamp'>{msg['time']}</div>" if "time" in msg else ""
    if msg["role"] == "user":
        with st.chat_message("user", avatar="img/user.png"):
            st.markdown(f"<div style='text-align: right'>{msg['content']}{timestamp}</div>", unsafe_allow_html=True)
    elif msg["role"] == "assistant":
        with st.chat_message("assistant", avatar="img/logo.png"):
            idx = st.session_state.messages.index(msg)
            escaped = msg["content"].replace('"', "&quot;").replace("'", "&#39;")
    
            question = ""
            answer = msg["content"]
            if idx > 0 and st.session_state.messages[idx - 1]["role"] == "user":
                question = st.session_state.messages[idx - 1]["content"]
    
            # üí° Keine Bewertung f√ºr Begr√º√üung oder Abbruch
            if idx == 0 or msg["content"].strip() == "Antwort wurde abgebrochen.":
                st.markdown(f"""
                    <div style="position: relative;">
                        <div style="white-space: pre-wrap;">{msg['content']}</div>
                        <button onclick="navigator.clipboard.writeText(`{escaped}`)" 
                                title="Kopieren" 
                                style="position: absolute; top: 0; right: 0; background: none; border: none; cursor: pointer; font-size: 16px;">
                            üìã
                        </button>
                        <div class='timestamp'>{msg['time']}</div>
                    </div>
                """, unsafe_allow_html=True)
            else:
                # Normale Antwort mit Bewertung
                col1, col2, col3, col4 = st.columns([10, 1, 1, 1])  # –¥–æ–±–∞–≤–∏–ª–∏ –æ—Ç–¥–µ–ª—å–Ω—É—é –∫–æ–ª–æ–Ω–∫—É
                with col1:
                    st.markdown(f"""
                        <div style="position: relative;">
                            <div style="white-space: pre-wrap;">{msg['content']}</div>
                            <div class='timestamp'>{msg['time']}</div>
                        </div>
                    """, unsafe_allow_html=True)
                
                # üëç / üëé ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –±—ã–ª –¥–∞–Ω —Ñ–∏–¥–±–µ–∫
                feedback_key = generate_message_key(question, answer, msg["time"])
                if not st.session_state.feedback_given_per_message.get(feedback_key):
                    with col2:
                        if st.button("üëç", key=f"thumbs_up_{idx}"):
                            save_message_feedback(question, answer, 1)
                            st.session_state.feedback_given_per_message[feedback_key] = True
                            st.session_state.feedback_thanks = True
                            st.rerun()
                
                    with col3:
                        if st.button("üëé", key=f"thumbs_down_{idx}"):
                            save_message_feedback(question, answer, -1)
                            st.session_state.feedback_given_per_message[feedback_key] = True
                            st.session_state.feedback_thanks = True
                            st.rerun()
                
                # üìã ‚Äî –≤—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
                with col4:
                    copy_button(escaped)

# ‚è≥ Diese Funktion sorgt daf√ºr, dass Streamlit nach einer kurzen Verz√∂gerung neu geladen wird.
# Sie wird z.‚ÄØB. genutzt, um kurz eine Erfolgsmeldung zu zeigen und dann die Oberfl√§che zu aktualisieren.
import threading

def trigger_delayed_rerun(delay_sec: float = 2):
    # Diese innere Funktion wartet x Sekunden und startet dann ein Re-Rendern (Neuladen)
    def rerun_later():
        import time
        time.sleep(delay_sec)     # Wartezeit in Sekunden
        st.experimental_rerun()   # Seite neu laden

    # Starte die Wartezeit in einem eigenen Thread (damit die Hauptanwendung nicht blockiert wird)
    threading.Thread(target=rerun_later).start()

# ‚úÖ Wenn nach einer Nachricht eine Feedback-Dankesch√∂n-Nachricht gezeigt werden soll:
if st.session_state.feedback_thanks:
    container = st.empty()  # Ein leerer Platzhalter f√ºr die Erfolgsmeldung
    container.success("‚úÖ Danke f√ºr dein Feedback! üëç")  # Zeige Erfolgsmeldung

    time.sleep(2)  # Zeige sie f√ºr 2 Sekunden

    container.empty()  # Danach entfernen wir die Meldung wieder

    # Status zur√ºcksetzen ‚Äì damit die Nachricht nur einmal erscheint
    st.session_state.feedback_thanks = False
                    
# üßë‚Äçüíº Admin-Feedback-Modus
# Dieser Bereich ist nur sichtbar, wenn:
# ‚Äì der Admin-Modus aktiviert ist UND
# ‚Äì Feedback zur letzten Antwort aktiviert wurde
if st.session_state.feedback_mode and st.session_state.is_admin:
    st.markdown("### üó≥Ô∏è War die Antwort korrekt?")  # √úberschrift f√ºr Admin-Feedback

    # Zwei Spalten f√ºr zwei Buttons: ‚úÖ und ‚ùå
    col1, col2 = st.columns(2)

    # ‚úÖ Antwort war korrekt
    with col1:
        if st.button("‚úÖ Antwort war korrekt"):
            st.success("Danke f√ºr dein Feedback! üôå")  # Erfolgsmeldung
            st.session_state.feedback_mode = False    # Feedback-Modus deaktivieren
            st.rerun()  # Seite neu laden

    # ‚ùå Antwort war falsch
    with col2:
        if st.button("‚ùå Antwort war falsch"):
            st.session_state.feedback_incorrect = True  # Weiter zur Korrektureingabe

# Wenn Admin sagt, dass die Antwort falsch war ‚Üí Textfeld f√ºr manuelle Korrektur anzeigen
if st.session_state.feedback_incorrect and st.session_state.is_admin:
    # Textfeld, um die korrekte Antwort einzugeben
    correct_answer = st.text_area("‚úçÔ∏è Bitte gib die richtige Antwort ein:", height=100)

    # üíæ Speichern-Button
    if st.button("üíæ Antwort speichern"):
        # Urspr√ºngliche Frage (die zweitletzte Nachricht im Verlauf)
        original_question = st.session_state.messages[-2]["content"]

        # Manuell korrigierte Antwort wird zur Wissensdatenbank hinzugef√ºgt
        st.session_state.bot.knowledge_base.add_entry(original_question, correct_answer)

        # Best√§tigung anzeigen
        st.success("‚úÖ Richtige Antwort wurde gespeichert!")

        # Feedback-Zust√§nde zur√ºcksetzen
        st.session_state.feedback_mode = False
        st.session_state.feedback_incorrect = False
        del st.session_state.latest_answer

        # Seite neu laden
        st.rerun()
